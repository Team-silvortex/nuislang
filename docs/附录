A1. 项目结构与命名空间映射
/proj
 ├─ src/
 │   ├─ cpu/
 │   │   └─ Main.nuis         → cpu::Main
 │   ├─ shader/
 │   │   └─ Blur.nuis         → shader::Blur
 │   └─ kernel/
 │       └─ FFT.nuis          → kernel::FFT
 └─ nuis.config.yaml

A2. CPU + 事件 + async/await
mod cpu Main {
    event FrameReady(texture: Texture2D, uv: vec2<f32>);
    delegate fn OnProcessed(id: u32) -> bool;

    fn run() {
        emit FrameReady(scene_tex(), vec2<f32>(0.5, 0.5));
    }

    on FrameReady(tex: Texture2D, uv: vec2<f32>) async {
        let out = shader::Blur::apply(tex, uv);
        let ok: bool = await kernel::FFT::analyze(out);
        if ok { log("processed"); }
    }
}

A3. 内联 shader（WGSL 兼容子语法）
mod shader Blur {
    fn apply(tex: Texture2D, uv: vec2<f32>) -> vec4<f32> {
        shader {
            // WGSL-ish 子语法区域
            let c: vec4<f32> = textureSample(tex, uv);
            return vec4<f32>(c.rgb * 0.85, c.a);
        }
    }
}

A4. Kernel 并行入口（后端决定线程语义）
mod kernel FFT {
    fn analyze(img: Texture2D) -> bool {
        let spec = compute(img);
        return spec.energy() > 0.1;
    }

    // kernel(...) 声明并行上下文形参（示例 thread_id）
    kernel(thread_id: u32, len: u32) {
        // 普通 Nuis 语句块，由后端映射到 SPIR-V/PTX
        if thread_id < len {
            // ... 并行体 ...
        }
    }

    fn compute(img: Texture2D) -> Spectrum { /* 调度 kernel(...) */ }
}

A5. comptime（编译期执行）
mod cpu Consts {
    comptime fn gen_scale(level: u32) -> f32 { 1.0 + (level as f32) * 0.1 }
    const SCALE: f32 = gen_scale(3); // 编译期折叠为 1.3
}

A6. 所有权：默认移动，显式 copy / 受限 ref
mod cpu Own {
    struct Buf { data: Bytes }
    fn f() {
        let a = Buf{ data: bytes() };
        let b = a;            // move：a 之后不可再用
        let c = copy b;       // 显式复制：b 可用，c 为副本
        use_buf(ref c);       // 受限借用：函数内只读/不可转移
    }
    fn use_buf(x: ref Buf) { /* 只读访问 */ }
}

附录 B：WGSL 子语法边界（内联 shader）

目标：shader { ... } 内部尽量接近 WGSL；与主语法词法隔离，避免冲突。

词法切换

看到关键字 shader 后紧跟 {，进入 shader 子词法模式；直到匹配到配对的 } 返回主词法。

子模式内允许 WGSL 标识符、内置类型（vec2<f32> 等）、函数、内建（textureSample、sin …）。

名称解析

子块内不捕获外部 Nuis 作用域（保持纯计算/可替换性）。

允许通过域桥接的受限内置（如绑定句柄、常量映射），由后端注入。

类型与返回

子块以 return <expr> 结束（若父函数声明返回类型）。

不允许在子块内声明 Nuis 类型，仅可用 WGSL 类型别名或内置向量/矩阵。

副作用约束

禁止 I/O 与全局可见副作用（除经由后端声明的存储写入）。

允许纹理采样/存储、算子运算、局部控制流。

附录 C：语法/词法冲突与判定规则（v0.1）
冲突点	说明	规避/判定
shader { 与普通块	需要词法切换	关键字 shader 后必须紧随 {，视为子语法；否则按标识符处理
kernel(...) <block> vs fn	都以标识符开头	kernel 保留字 + 以 ( 起，判定为并行入口；fn 为常规函数
some(...) / none	既是可选字面量又可做模式	作为 <literal> 或 <pattern> 时不冲突；解析器按产生式位置决定
ref	类型前缀 vs 标识符	在 <type_expr> 前缀位置解析为修饰符，否则为标识符
copy	一元操作符 vs 标识符	在 <unary_op> 位置视为操作符，否则为标识符
::	命名空间	仅用于路径分隔；. 仅用于成员访问
关键字遮蔽	标识符与关键字同名	关键字不可作为标识符；建议 IDE 在保存时即报错

运算符优先级（高→低）
一元：copy ! - → 乘除 % → 加减 → 位与 & → 位异或 ^ → 位或 | → 比较 == != < > <= >= → 逻辑与 && → 逻辑或 ||.

附录 D：所有权与借用小抄（v0.1）

默认移动：赋值、传参均移动所有权。

显式复制：copy expr 触发拷贝（类型需实现可拷贝语义）。

受限借用：类型前缀 ref T 仅在函数签名与变量类型位置出现，表示受限只读借用；借用期由编译器按语句块内联推导（不暴露显式生命周期标注）。

禁止裸指针/不安全块：底层能力交给 Nurs（Rust FFI）。

可选值：T?、some(v)、none；模式匹配：match opt { some(x) => {...}; none => {...}; }.

附录 E：Nustar 插件注册（YAML 摘要）
# nuis.config.yaml
project:
  name: "demo"
modules:
  - name: "audio"                 # 自定义域名（非内置）
    plugin: "nustar-audio"        # 插件包名
    path: "./extensions/nustar-audio/"
    backend: "auto"               # auto/cpu/gpu/npu
cache:
  enabled: true
runtime:
  daemon: true


nuis-rc 启动：读取 YAML → 注册域 → 载入解析/Lower → 供 nuisc 使用。
未注册域但代码里出现 mod audio ... → 编译期报错并提示安装插件。

附录 F：典型诊断与报错格式

未知域

E1001: unknown module domain 'audio'
help: install/register plugin 'nustar-audio' in nuis.config.yaml


ABI 不匹配（标准库/后端）

E2103: std@1.1.0_abi1 incompatible with compiler abi=0
note: required abi=1, found abi=0
help: run `nuis toolchain use nuisc@0.5.x (abi=1)`


移动后使用

E3102: use of moved value 'a'
note: 'a' was moved here: line 5: let b = a;
help: consider `let b = copy a;` or pass by `ref`


shader 子语法错误

E4205 (shader): expected 'return <expr>' before '}'
note: shader blocks must return the declared function type

附录 G：CLI 速览（与上下文相关）
nuis build            # 在项目上下文构建（锁定 std/abi/后端）
nuis run              # 运行沙箱产物
nuis sandbox up|stop  # 启停项目守护
nuis plugin add ...   # 通过 nuis 客户端安装全局只读包
nuis cache clean      # 清理项目/全局缓存（安全）
