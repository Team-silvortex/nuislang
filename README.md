# 🪶 **NuisLang Whitepaper v0.43**

### A Semantics-First Execution Model for Heterogeneous Systems

**MIT License**

---

# 0. 引言 · 为什么需要新的执行模型

计算平台正在发生结构性变化：

* 单一 CPU 不再是中心
* GPU / NPU / WASM / 专用加速器成为常态
* **数据迁移与同步成本正在系统性地超过纯计算成本**
* 执行位置、生命周期、同步边界与调度策略成为一等问题

然而，**主流语言与运行时的核心假设仍然停留在单域、CPU 优先、隐式调度的时代**。

Nuis 并非试图“取代”现有语言或框架。它的目标更明确，也更克制：

> **为异构计算时代提供一个长期稳定的“语义—执行”分离模型，
> 在不牺牲程序可理解性的前提下，系统性管理执行位置、数据流动与同步秩序。**

Nuis 关注的是 **执行模型的可持续性与可分析性**，而非短期性能或平台红利。

---

# 1. 设计原则（Design Principles）

Nuis 的设计建立在三条长期稳定轴之上：

| 维度         | 含义            | 目标   |
| ---------- | ------------- | ---- |
| **语义稳定性**  | 程序“意图”不随硬件变化  | 长期不变 |
| **执行可替换性** | 执行策略可随时代演进    | 可演化  |
| **调度可分析性** | 调度、迁移与同步行为可推导 | 可验证  |

### 核心原则

1. **用户描述意图，而非执行路径**
2. **执行位置与调度是系统责任，而非用户负担**
3. **语义优先于性能优化**
4. **安全来自一致、可验证的语义模型**
5. **IR 是系统边界，而非语言语法的副产物**

---

# 2. NIR：语义意图表示（Semantic Intent IR）

NIR（Nuis Intent Representation）是 Nuis 的最高层表示。

NIR 仅描述：

* 程序的**语义意图**
* 操作之间的**逻辑关系**
* 抽象资源的使用方式

**NIR 明确不包含：**

* 执行域（CPU / GPU / NPU）
* 生命周期与同步细节
* 调度策略
* 内存布局与迁移路径

示例：

```nuis
let buf = Buffer<f32>(1024)
buf.fill(1.0)
buf.normalize()
```

在 NIR 中表示为：

* Allocate(1024)
* Fill(1.0)
* Normalize()

NIR 是 **“程序意义”的最小不变量**，也是所有后续 IR 的语义锚点。

---

# 3. YIR：跨域调度表示（Cross-Domain Scheduling IR）

YIR 是 Nuis 的核心执行中间表示。

YIR 将 NIR 的语义意图映射为一个**显式、可分析的跨执行域调度结构**，用于统一描述：

* 计算节点（Compute Nodes）
* 数据与控制依赖
* 执行域映射与迁移决策
* 同步点与生命周期边界

### 3.1 结构特性

* YIR **不是单纯的数据流图**
* YIR 允许：

  * 显式控制流节点
  * 同步边界节点
  * 资源迁移节点
* 在消除循环与控制展开后，**调度层面可被规约为 DAG**，用于静态分析与验证

YIR 的目标不是“最大并行度”，而是：

> **在异构执行条件下，保持执行秩序的可解释性与可预测性。**

---

# 4. GLM：图生命周期模型（Graph Lifetime Model）

GLM 定义了 YIR 层的正式资源与生命周期语义。

## 4.1 值分类

### `val`

* SSA 中间值
* 不跨节点
* 不进入生命周期分析

### `res`

* 资源型对象（Buffer / Image / Tensor / Handle）
* 可跨节点、跨执行域存在
* **必须受 GLM 管理**

---

## 4.2 资源使用模式（UseMode）

* **Own**：唯一所有权
* **Write**：独占可变访问
* **Read**：共享只读访问

约束规则：

* 任意时刻仅允许一个 `Own`
* `Write` 不可并发
* `Read` 可并发

这些约束在 **编译期静态验证**。

---

## 4.3 生命周期区域（Region）

Region 表示一个资源在整个执行图中的合法使用区间。

非法情形包括：

* 定义前使用
* Drop 后使用
* 重复所有权
* 跨执行域未迁移即访问

GLM 的目标是：

> **在编译期消除跨域资源使用中的未定义行为。**

---

## 4.4 跨域迁移（Domain Move）

```text
send %buf -> GPU
```

表示：

* 资源所有权从 CPU 域迁移至 GPU 域
* 生命周期区域随之扩展
* 源执行域立即失效

迁移本身是 **一等语义事件**，而非隐式优化。

---

# 5. Data Fabric IR：数据传播与同步平面

随着异构系统复杂度上升，**数据分发与同步已成为系统主导成本**。

为此，Nuis 在 v0.43 中正式引入 **Data Fabric IR** 的概念层：

> **Data Fabric IR 是描述跨执行域数据传播、同步与可见性的中介表示层。**

### 5.1 设计定位

* Data Fabric IR **不是通用计算 IR**
* 它描述的是：

  * 数据所在位置（memory space）
  * 数据迁移路径（copy / map / peer transfer）
  * 同步与完成事件（event / fence / token）

可类比为：

> **异构系统中的“跨国高速公路”，而非城市内部道路。**

---

## 5.2 与 CPU Mod 的关系

* **CPU Mod（非 DF 核）内部**：

  * 使用普通函数调用、内存访问与同步原语
  * 不强制 dataflow 或 fabric 语义

* **Fabric 边界处**：

  * 显式进入 Data Fabric IR
  * 统一处理跨域迁移、同步与一致性

该分界是 **系统复杂度可控的关键**。

---

# 6. Domain IR：物理特化层

YIR 可被特化为不同执行域的 Domain IR：

* **CPU IR**：对应 Rust MIR / LLVM IR
* **GPU IR**：结构化计算 IR（SPIR-V / CUDA / Metal）
* **NPU IR**：图化或流水线式执行表示
* **WASM IR**：安全沙箱执行域

Domain IR 仅负责 **如何执行**，不改变上层语义。

---

# 7. Nurs：YIR-CPU ↔ Rust MIR 语义桥

Nurs 是 YIR-CPU 与 Rust MIR 之间的语义映射层：

* 无 C ABI
* 无绑定胶水层
* **语义对齐而非接口对齐**

YIR 是主轴，Rust MIR 只是可替换后端之一。

---

# 8. 执行模型：Fabric Core 与专用 CPU 核

为保证调度与同步的确定性，Nuis 允许：

* Data Fabric IR 的执行逻辑
* 在 **长期绑定的专用 CPU 核** 上运行

该模型借鉴：

* DPDK / SPDK 的 lcore 设计
* 控制面 / 数据面分离思想

其目标是：

> **用确定性与低抖动，换取系统整体的可预测性。**

---

# 9. Yalivia Runtime：执行与扩展层

Yalivia 是 Nuis 的可选运行时组件，用于：

* 动态调度实验
* 多语言接入（Go / Python / Lua）
* 异构执行策略探索

**Nuis 核心语义不依赖 Yalivia。**

---

# 10. 安全模型

安全由三层保证：

1. **GLM**：跨域资源一致性
2. **YIR / Fabric IR**：调度与同步可验证性
3. **Rust / WASM**：执行域内存安全

---

# 11. 当前状态（v0.43）

| 模块             | 状态   |
| -------------- | ---- |
| NIR            | 稳定   |
| YIR            | 稳定   |
| GLM            | 冻结   |
| Data Fabric IR | 设计确立 |
| Nurs           | 路径明确 |
| 工具链            | 架构完成 |

---

# 12. 路线图

* **v0.5**：YIR + Fabric 可执行原型
* **v0.6**：Nurs 原型
* **v0.7**：异构调度验证
* **v1.0**：稳定执行模型发布

---

# 结语

Nuis 不试图成为“下一门主流语言”。

它选择了一条更克制、也更艰难的道路：

> **在硬件持续变化的前提下，
> 让程序语义长期成立，
> 让执行秩序始终可解释。**

---
